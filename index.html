<html>
<head>
  <meta charset="utf-8">
  <title>rr: lightweight recording & deterministic debugging</title>

  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300'
        rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Cousine'
        rel='stylesheet' type='text/css'>

  <style type="text/css">
    html {
      width: 100%;
      font-size: 12pt;
    }
    body {
      font-family: 'Open Sans', sans;
      color: #484848;
    }
    body > * {
      max-width: 50rem;
      margin-left: auto;
      margin-right: auto;
    }

    #toprow {
      border: 1px solid gray;
      border-radius: 10px;
      display: flex;
      flex-direction: row;
    }

    #toprow > h1 {
      padding: 0 20px;
    }

    #video-container {
      max-width: none;
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      margin: 0;
    }

    #video-container > p {
      width: 560px;
      margin: 1em;
    }

    a {
      text-decoration: none;
      color: #0096DD;
    }

    h1 {
      display: inline;
      font-weight: 300;
      font-size: 5rem;
      margin: 0;
    }

    #topmenu {
      list-style-type: none;
      font-size: 1.2rem;
      line-height: 2;
      padding: 0;
    }
    #topmenu li {
      display: inline;
      font-weight: 300;
      padding: 1.5rem;
      white-space: nowrap;
    }
    #topmenu li a {
      text-decoration: none;
    }
    #sponsored {
      text-align: center;
    }

    h2 {
      text-align: center;
      font-weight: 300;
      font-size: 2rem;
      background-color: white;
    }

    h3 {
      font-weight: 300;
      font-size: 1.5rem;
    }

    code {
      font-family: 'Cousine';
    }
    pre {
      font-family: 'Cousine';
    }

    ul {
      list-style-type: circle;
    }

    footer {
      width: 100%;
      text-align: center;
    }

    #old {
      display: none;
      background-color: aqua;
      font-face: serif;
    }
    marquee {
      font-size: 72pt;
    }
    blink div {
      display: inline;
    }
  </style>
</head>

<body>
  <a href="https://github.com/rr-debugger/rr"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>

  <div id="old">
    <marquee scrollamount="40">
      <blink>
        <div>
          <div><img src="flag.gif"><img src="mchammer.gif"><img src="flag.gif">
            <img src="mchammer.gif"><img src="flag.gif"></div>
          <div><span>W</span><span>E</span><span>L</span><span>C</span><span>O</span><span>M</span><span>E</span> <span>T</span><span>O</span> <span>R</span><span>R</span></div>
          <div><img src="flag.gif"><img src="mchammer.gif"><img src="flag.gif">
            <img src="mchammer.gif"><img src="flag.gif"></div>
          <div><span>W</span><span>E</span><span>L</span><span>C</span><span>O</span><span>M</span><span>E</span> <span>T</span><span>O</span> <span>R</span><span>R</span></div>
          <div><img src="flag.gif"><img src="mchammer.gif"><img src="flag.gif">
            <img src="mchammer.gif"><img src="flag.gif"></div>
          <div><span>W</span><span>E</span><span>L</span><span>C</span><span>O</span><span>M</span><span>E</span> <span>T</span><span>O</span> <span>R</span><span>R</span></div>
          <div><img src="flag.gif"><img src="mchammer.gif"><img src="flag.gif">
            <img src="mchammer.gif"><img src="flag.gif"></div>
          <div><span>W</span><span>E</span><span>L</span><span>C</span><span>O</span><span>M</span><span>E</span> <span>T</span><span>O</span> <span>R</span><span>R</span></div>
          <div><img src="flag.gif"><img src="mchammer.gif"><img src="flag.gif">
            <img src="mchammer.gif"><img src="flag.gif"></div>
          <div><span>W</span><span>E</span><span>L</span><span>C</span><span>O</span><span>M</span><span>E</span> <span>T</span><span>O</span> <span>R</span><span>R</span></div>
          <div><img src="flag.gif"><img src="mchammer.gif"><img src="flag.gif">
            <img src="mchammer.gif"><img src="flag.gif"></div>
        </div>
      </blink>
    </marquee>
    <section>
      <p><i>Last updated Fri Oct 18 17:19</i></p>
      <p><a href="http://www.microsoft.com/ie"><img src="ie.gif"></a></p>
    </section>
  </div>

  <div id="toprow">
    <h1>rr</h1>

    <div>
      <ul id="topmenu">
        <li><a href="https://github.com/rr-debugger/rr">github</a></li>
        <li><a href="https://groups.google.com/g/rr-devel">mailing
            list</a></li>
        <li><a href="https://github.com/rr-debugger/rr/wiki/News">news</a></li>
       <li><a href="https://chat.mozilla.org/#/room/#rr:mozilla.org">#rr on chat.mozilla.org</a></li>
      </ul>
      <div id="sponsored">Development sponsored by <a href="https://pernos.co">Pernosco</a></div>
    </div>
  </div>

  <h2>what rr does</h2>
  <h3>rr aspires to be your primary C/C++ debugging tool for Linux, replacing &mdash;
    well, enhancing &mdash; gdb.  You record a failure once, then
    debug the recording, deterministically, as many times as you want.
    The same execution is replayed every time.</h3>
  <h3>rr also provides efficient reverse execution
    under gdb. Set breakpoints and data watchpoints and quickly
    reverse-execute to where they were hit.</h3>
  <h3>rr works on real applications and is used
  <a href="https://github.com/rr-debugger/rr/wiki/Testimonials">by many</a>
  <a href="https://twitter.com/chandlerc1024/status/879962014860193792">developers</a>
  to fix real bugs. It makes debugging hard bugs much easier, but also speeds up
  debugging of easy bugs.</h3>
  <h3>rr features:
  <ul>
  <li>Low overhead compared to other similar tools, especially on mostly-single-threaded workloads
  <li>Supports recording and replay of all kinds of applications: Firefox, Chrome, QEMU, LibreOffice,
  Go programs, ...
  <li>Record, replay and debug multiple-process workloads, including entire containers
  <li>Works with gdb scripting and <a href="https://github.com/rr-debugger/rr/wiki/Using-rr-in-an-IDE">IDE integration</a>
  <li><a href="http://robert.ocallahan.org/2017/06/new-rr-pack-command.html">Durable</a>,
  <a href="http://robert.ocallahan.org/2017/07/selecting-compression-algorithm-for-rr.html">compact</a> traces that
  can be <a href="http://robert.ocallahan.org/2017/09/rr-trace-portability.html">ported</a> between machines
  <li><a href="http://robert.ocallahan.org/2016/02/introducing-rr-chaos-mode.html"><em>Chaos mode</em></a> to
  make intermittent bugs more reproducible
  </ul>

  <h2>the rr debugging experience</h2>
  <section>
    <p>
      <!-- TODO: add to or replace with inline video
      demonstration. -->
    <p>
      Start by using rr to record your application:
      <pre>$ rr record /your/application --args
...
FAIL: oh no!</pre>
    <p>
      The entire execution, including the failure, was saved to disk.
      That recording can now be debugged.
      <pre>$ rr replay
GNU gdb (GDB) ...
...
0x4cee2050 in _start () from /lib/ld-linux.so.2
(gdb)</pre>
    <p>
      Remember, you're debugging the <em>recorded trace</em>
      deterministically; <em>not</em> a live, nondeterministic
      execution.  The replayed execution's address spaces, register
      contents, syscall data etc are exactly the same in every run.
    <p>
      Most of the common gdb commands can be used.
      <pre>(gdb) break mozilla::dom::HTMLMediaElement::HTMLMediaElement
...
(gdb) continue
Continuing.
...
Breakpoint 1, mozilla::dom::HTMLMediaElement::HTMLMediaElement (this=0x61362f70, aNodeInfo=...)
...</pre>
    <p>
      If you need to restart the debugging session, for example
      because you missed breaking on some critical execution point, no
      problem.  Just use gdb's <code>run</code> command to restart
      replay.
      <pre>(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
...
Breakpoint 1, mozilla::dom::HTMLMediaElement::HTMLMediaElement (this=0x61362f70, aNodeInfo=...)
...
(gdb) </pre>
    <p>
      The <code>run</code> command started another replay run of your
      recording from the beginning.  But after the session restarted,
      the <em>same execution</em> was replayed again.  And all your
      debugging state was preserved across the restart.
    <p>
      Note that the <code>this</code> pointer of the
      dynamically-allocated object was the same in both replay
      sessions.  Memory allocations are exactly the same in each
      replay, meaning you can hard-code addresses you want to watch.
    <p>
      Even more powerful is reverse execution. Suppose we're debugging Firefox layout:
<pre>Breakpoint 1, nsCanvasFrame::BuildDisplayList (this=0x2aaadd7dbeb0, aBuilder=0x7fffffffaaa0, aDirtyRect=..., aLists=...)
    at /home/roc/mozilla-inbound/layout/generic/nsCanvasFrame.cpp:460
460   if (GetPrevInFlow()) {
(gdp) p mRect.width
12000</pre>
      We happen to know that that value is wrong. We want to find out where it was set.
      rr makes that quick and easy.
<pre>(gdb) watch -l mRect.width
(gdb) reverse-cont
Continuing.
Hardware watchpoint 2: -location mRect.width
Old value = 12000
New value = 11220
0x00002aaab100c0fd in nsIFrame::SetRect (this=0x2aaadd7dbeb0, aRect=...)
    at /home/roc/mozilla-inbound/layout/base/../generic/nsIFrame.h:718
718       mRect = aRect;</pre>
     This combination of hardware data watchpoints with reverse execution is extremely powerful!
  </section>

    <h2>video</h2>
  <section id="video-container">
    <p>
      This video shows a quick demo of rr recording and replaying Firefox.
      <iframe width="560" height="315" src="https://www.youtube.com/embed/hYsLBcTX00I" frameborder="0" allowfullscreen></iframe>
    <p>
      This video demonstrates rr's basic capabilities in a bit more
      detail.
      <iframe width="560" height="315" src="https://www.youtube.com/embed/61kD3x4Pu8I" frameborder="0" allowfullscreen></iframe>
    <p>
      This video is a high-level technical talk by Robert O'Callahan about rr.
      <iframe width="560" height="315" src="https://www.youtube.com/embed/H4iNuufAe_8" frameborder="0" allowfullscreen></iframe>
  </section>

  <h2>getting started</h2>
  <section>
    <div>
      <h3>Build from source</h3>
      <a href="https://github.com/rr-debugger/rr/wiki/Building-And-Installing">Follow
            these instructions.</a> Recommended if the packages don't work for you --- kernel changes and OS updates sometimes require rr changes.
      </h3>
    </div>

    <div>
      <h3>Or in Fedora:</h3>
      <pre>cd /tmp
wget https://github.com/rr-debugger/rr/releases/download/<span class=ver>5.5.0</span>/rr-<span class=ver>5.5.0</span>-Linux-$(uname -m).rpm
sudo dnf install rr-<span class=ver>5.5.0</span>-Linux-$(uname -m).rpm</pre>
<!--      <p>You can also install rr directly from the package manager.</p>
      <pre>sudo dnf install rr</pre> -->
    </div>

    <div>
      <h3>Or in Ubuntu:</h3>
      <pre>cd /tmp
wget https://github.com/rr-debugger/rr/releases/download/<span class=ver>5.5.0</span>/rr-<span class=ver>5.5.0</span>-Linux-$(uname -m).deb
sudo dpkg -i rr-<span class=ver>5.5.0</span>-Linux-$(uname -m).deb</pre>
    </div>

    <div>
      <h3>Running rr</h3>
      <p>
        <a href="https://github.com/rr-debugger/rr/wiki/Usage">Follow the
        usage instructions</a> to learn how to use rr.
      <p>
        If you're using rr to debug Firefox, you may find
        <a href="https://github.com/rr-debugger/rr/wiki/Recording-Firefox">
        these setup instructions</a> helpful. They cover how to use rr to
        record Firefox test suites.
    </div>
  </section>

  <h2>background and motivation</h2>
  <section>
    <p>
      rr's original motivation was to make debugging of intermittent failures
      easier. These failures are hard to debug because any given program run
      may not show the failure. We wanted to create a tool that would record
      program executions with low overhead, so you can record test executions
      until you see a failure, and then replay the failing execution
      repeatedly under a debugger until it has been completely understood.
    <p>
      We also hoped that deterministic replay would make debugging of any kind of bug
      easier. With normal debuggers, information you learn during the debugging
      session (e.g. the addresses of objects of interest, and the ordering of important
      events) often becomes obsolete when you have to rerun the testcase.
      With deterministic replay, that never needs to happen: your knowledge of
      what happens during the failing run increases monotonically.
    <p>
      Furthermore, since debugging is the process of tracing effects to
      their causes, it's much easier if your debugger can execute backwards in time.
      It's well-known that
      given a record/replay system which provides restartable checkpoints during replay,
      you can simulate reverse execution to a particular point in time by restoring
      the previous checkpoint and executing forwards to the desired point. So we hoped
      that if we built a low-overhead record-and-replay system that works well on the
      applications we care about (Firefox), we could build a really usable backend for
      gdb's reverse execution commands.
    <p>
      <strong>These goals have all been met.</strong> rr is not only a working
      tool, but it's being used regularly by developers on many large and small projects.
    <p>
      rr records a group of Linux user-space processes and captures all
      inputs to those processes from the kernel, plus any nondeterministic CPU
      effects performed by those processes (of which there are very few).
      rr replay guarantees that execution preserves instruction-level control flow
      and memory and register contents.
      The memory layout is always the same, the addresses of objects
      don't change, register values are identical, syscalls return the
      same data, etc.
    <p>
      Tools like fuzzers and randomized fault injectors become even
      more powerful when used with rr.  Those tools are very good at
      triggering <em>some</em> intermittent failure, but it's often
      hard to reproduce <em>that same</em> failure again to debug it.
      With rr, the randomized execution can simply be recorded.  If
      the execution failed, then the saved recording can be used to
      deterministically debug the problem.
    <p>
      rr lowers the cost of fixing bugs.  rr helps produce
      higher-quality software for the same cost. rr also makes
      debugging more fun.
  </section>
  <h2>rr in context</h2>
  <section>
    <p>
      Record-and-replay debugging is an old idea; many systems
      preceded rr.  What makes rr different are the
      design goals:
      <ul>
        <li><em>Initial focus on Firefox</em>. Many record
          and replay techniques require specific programming languages or
          don't scale well and thus can't handle Firefox --- or were just
          experimental and were never fleshed out. Firefox is
          a complex application, so given rr is useful for debugging
          Firefox, it is likely to be generally useful.
        <li><em>Deployability</em>. rr runs on stock
          Linux kernels, on commodity hardware, and requires no
          system configuration changes. Many record and replay techniques
          require kernel changes. Many rely on running the OS in a virtual
          machine.
        <li><em>Low run-time overload</em>. We want rr to replace
          gdb in your workflow. That means you need to start getting
          results with rr about as quickly as you would if you were
          using gdb. Low overhead also means less perturbation of tests.
        <li><em>Simplicity of design</em>. We didn't have a lot of resources
          to develop rr, so we avoided approaches that rely on complex techniques
          such as dynamic binary instrumentation. This simplicity has also made
          rr more robust and lower overhead.
      </ul>
    <p>
      The overhead of rr depends on your application's workload.  On
      Firefox test suites, rr's recording performance is quite usable.
      We see slowdowns down to &le; 1.2x.  A 1.2x slowdown means that if
      the suite takes 10 minutes to run by itself, it will take around
      12 minutes to be recorded by rr.  However, overhead can vary dramatically
      depending on the workload. For mostly-single-threaded programs, rr has
      much lower overhead than any competing record-and-replay system we know of.
  </section>

  <h2>limitations</h2>
  <section>
    <p>rr &hellip;
    <ul>
      <li>emulates a single-core machine. So, parallel programs incur
        the slowdown of running on a single core. This is an inherent
        feature of the design.
      <li>cannot record processes that share memory with processes
        outside the recording tree. This is an inherent feature of the
        design. rr automatically disables features such as X shared
        memory for recorded processes to avoid this problem.
      <li>requires a reasonably modern x86 CPU. It depends on certain
        performance counter features that are not available in older
        CPUs.
      <li>requires knowledge of every system call executed by the
        recorded processes. It already supports a wide range of
        syscalls &mdash; those needed by Firefox and other applications people
        have tackled with rr &mdash; but support
        isn't complete, so running rr on your application may
        uncover a syscall that needs to be implemented. Please
        <a href="https://github.com/rr-debugger/rr/issues/">file github issues</a>
        for unsupported system calls.
      <li>sometimes needs to be updated in response to kernel changes,
        updates to system libraries, or new CPU families. If rr isn't working
        for you (and the above caveats do not apply), please
        <a href="https://github.com/rr-debugger/rr/issues/">file an issue</a>.
    </ul>
  </section>

  <h2>further reference</h2>
  <section>
    <p>
      The <a href="https://arxiv.org/pdf/1705.05937.pdf">Extended Technical Report</a>
      is our best overview of how rr works and performs.
    <p>
      The <a href="https://github.com/rr-debugger/rr/wiki">rr wiki</a>
      contains pages that cover technical topics related to rr.
    <p>
      Ask on <a href="https://groups.google.com/g/rr-devel">the mailing
      list</a> or on <a href="https://chat.mozilla.org/#/room/#rr:mozilla.org">#rr on chat.mozilla.org</a> if you have questions about rr.
  </section>
</body>

<script type="text/javascript">
/*! konami-js v1.0.1 | http://mck.me/mit-license */
var Konami={};(function(d,e){var f=d.sequence=function(){var b=Array.prototype.slice.call(arguments),c=0;return function(a){a=a||e.event;a=a.keyCode||a.which||a;if(a===b[c]||a===b[c=0])a=b[++c],"function"===typeof a&&(a(),c=0)}};d.code=function(b){return f(38,38,40,40,37,39,37,39,66,65,b)}})(Konami,window);
document.onkeyup = Konami.code(function () {
  document.getElementById('old').style.display = 'block';
});
</script>

</html>
