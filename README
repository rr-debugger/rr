Installation guide for rr
=========================


A) Hardware/software requirements
---------------------------------
rr has two mode of operation: 
(1) Plain Mode:
Requires a Linux kernel version 2.6.39 and higher.
To enable PEBS support for the hardware performance counters (HPC) a
kernel version >= 3.0 is required. Was developed under Ubuntu 11.04 &
Ubuntu 12.04.
(2) Filter Mode (--filter_lib):

Requires kernel version 3.5 to support the seccomp-bpf filter, or
Ubuntu 12.04 as it was backported to its 3.2. Developed and tested
under Ubuntu 12.04.

Currently rr supports only recording and replaying of 32-bit x86 Linux
processes.  It can be built and run as a 32-bit application on an
x86_64 system; see below.

rr can run in a virtual machine that supports virtualization of
performance counters, such as VMWare Workstation 9. Installing the
latest 32-bit Ubuntu in a VM is an easy way to get rr working.

===============================================================================
*********************************** WARNING ***********************************
===============================================================================
rr needs to disable some modern OS security features to run correctly;
see below for more details.  Disabling these features in a
"production" system will put that system at significantly higher
security risk.  This is another very good reason to run rr in a
virtual machine.  Disabling network access to the VM is further
recommended.

rr requires libpfm-4.3.0 and libdisasm-0.23.  Follow the instructions
below to install the libraries for your distribution.

On Fedora 18:
 $ sudo yum install libpfm

Go to http://sourceforge.net/projects/bastard/files/libdisasm/0.23/
and download libdisasm-0.23.tar.gz.  Then run these commands

 $ tar zxvf libdisasm-0.23.tar.gz
 $ cd libdisasm-0.23
 $ ./configure && make
 $ sudo make install

On Ubuntu >= 10.04:
 $ sudo apt-get install libdisasm-dev

Go to
http://sourceforge.net/projects/perfmon2/files/libpfm4/libpfm-4.3.0.tar.gz/download
libpfm-4.3.0.tar.gz.  Then run these commands

 $ tar zxvf libpfm-4.3.0.tar.gz
 $ cd libpfm-4.3.0
 $ ./configur && make
 $ sudo make install


B) Building
-----------

rr is currently developed with the Eclipse CDT plugin. You can import
the project directly into Eclipse. Eclipse then generates a makefile
which you can use to build the project.

By default Eclipse will automatically build the project when files
change.  You can force Eclipse to rebuild the project by pressing
Ctrl-B.


C) Building on x86_64 systems
-----------------------------

On a 64-bit system, rr expects to find the 32-bit versions of those
libraries installed under $(HOME)/32bit, so you should download those
libraries and build them yourself.

To build the 32-bit version of libdisasm-dev, run configure like so:

 $ ./configure --prefix=$HOME/32bit --build=i686-pc-linux-gnu "CFLAGS=-m32" "CXXFLAGS=-m32" "LDFLAGS=-m32"

To build the 32-bit version of libpfm-4.3.0, edit config.mk and patch
it like this:

@@ -65,8 +65,10 @@
 endif
 ifeq (mips,$(findstring mips,$(ARCH)))
 override ARCH=mips
 endif
+override ARCH=i386
+OPTIM=-O3 -m32
 
 ifeq (MINGW,$(findstring MINGW,$(SYS)))
 override SYS=WINDOWS
 endif
@@ -100,9 +102,9 @@
 
 #
 # Where should things (lib, headers, man) go in the end.
 #
-PREFIX=/usr/local
+PREFIX=$(HOME)/32bit
 LIBDIR=$(PREFIX)/lib
 INCDIR=$(PREFIX)/include
 MANDIR=$(PREFIX)/share/man
 DOCDIR=$(PREFIX)/share/doc/libpfm-$(VERSION).$(REVISION).$(AGE)
@@ -187,8 +189,9 @@
 LDCONFIG=true
 else
 DBG?=-g -Wall -Werror -Wextra -Wno-unused-parameter
 endif
+LDCONFIG=true
 
 CFLAGS+=$(OPTIM) $(DBG) -I$(SYSINCDIR) -I$(PFMINCDIR)
 MKDEP=makedepend
 PFMLIB=$(PFMLIBDIR)/libpfm.a

You will need to run rr with LD_LIBRARY_PATH=$HOME/32bit/lib.


D) Usage
--------

rr cannot run with address space randomization (for obvious reasons)
or ptrace hardening, because rr must write to /proc/$pid/mem.  These
must be disabled before calling either the recorder or the replayer.
You can do this "permanently" (persistent across reboots) by adding
these lines to your system's /etc/sysctl.config

###################################################################
## Options for rr
kernel.randomize_va_space = 0
kernel.yama.ptrace_scope = 0

and rebooting.  Alternatively, if you're running rr "one-off" on a
production machine (not recommended), you can temporarily set up rr by
running

 $ $rr/src/script/setup.sh

By default in the current build system, Eclipse will create an
executable called $rr/Debug/RecordReplayDebug.  Running that
executable in "record" mode creates a path in the current directory
which contains the trace file(s).  It's recommended to run rr from
within a scratch directly outside the $rr clone.  For example

 $ cd $rr/..
 $ mkdir scratch-rr
 $ cd scratch-rr
 $ ln -s ../rr/Debug/RecordReplayDebug rr  # save some typing

Then To invoke the recorder, run

 $ ./rr --record /path/to/binary

The trace is saved to the path trace_$n.

To replay an application trace saved to the directory trace_$n, run

 $ ./rr --replay trace_$n

NB: rr currently doesn't make a copy of the traced binary(ies) or
dependent libraries, so these must remain unchanged between recording
and replay.  Otherwise replay will result in undefined behavior.

Other command line options:
[--filter_lib=<path>] : Only for kernels >= 3.5; this installs a
wrapper for several system calls (look at share/wrap_syscalls.c) to
speed up their handling and save on the ptrace() context switch. The
wrapper is compiled as a shared object called 'libwrap_syscalls.so'
(as part of rr compilation process) and can be found in the rr
executable directory.

Debug command line options:
[--dump_on=<syscall|-signal>] : dump the entire memory to file every
time the system call numbered <syscall> is encountered or a signal
numbered by <signal> is encountered. The negation if signal is
required to distingish between syscalls and signals of the same
number.  example: --dump_on=79 : dumps all memory every time
gettimeofday is entered. --dump_on=-17: dumps all memory every time
signal SIGCHLD is recieved.

[--dump_at=<time>] : dump the entire memory at global time <time>

[--checksum={on-syscalls,on-all-events}|<from-time>] : For record:
calculated a checksum of the entire memory either on every event
(on-all-events) or on every syscall (on-syscalls) or starting from
global time <from-time>. Fore replay: verifies the calculated
checksums, should be run with same arguments as the record.

[--redirect_output] : during replay, write to stdout and stderr output
that was sent to those files during recording.  In theory this could
affect the integrity of the replay, however this is usually the
behavior one expects.

Note that talking to particular kernel drivers (by ioctl(...))
requires the rr to have knowledge about what the driver is doing. For
example, if you record GUI applications that make use a grapphics
driver with 3d-support rr will fail. If you're using NVidia binary
drivers, removing the xorg-x11-drv-nvidia-libs package will avoid this
problem.

Also, it is advised to turn off any CPU frequency scaling
capabilities, such as Intel Speed Step.  This can be achieved by
either turning it off in the BIOS or by disabling it in the kernel,
e.g. by setting the CPU governor to 'performance'. If neither of these
solutions is feasible, rr and its child processes should be pinned on
a certain core, e.g. by running rr with:

 $ taskset 0x1 rr <options>

or, in the case of a CPU that is able to run multiple threads on one
core in parallel, such as Intel CPUs with Hyperthreading capabilities,
it is better to use:

 $ taskset 0x3 rr <options>

Otherwise, due to frequent context switches between rr and the traced
process, the different cores will often scale down their frequency
which can lead to slowdowns of up to 2x.

